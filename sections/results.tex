\newpage
\section{Testing}

Designed update system was implemented. Viability of such solution was tested simulated updates to development version of firmware running on prototype board.

\subsection{Implementation details}

Set of python scripts was developed to aid with function compilation and packaging. Functions were discovered and allocated by searching function definitions from all source files. Global variables were extracted from symbol tables after all object files were compiled. Reason for this difference is that argument types must also be know about functions. Data about functions and globals, along with respective object codes, was stored in a SQLite3 database. Scripts were also created for generating interception header, linkerscript, and packages with headers.

Function table format was decided. It could not be implemented as branch table, as internal Flash and \gls{sram} are too far away in the memory space. Function table was therefore set to contain pointers, 4 bytes per function. Storing 3 bytes per function would require 2 instructions additional overhead per function call, so it was decided that 4 bytes per function will be stored (Appendix \ref{apx:calls}). Pointers are to point to the first instruction of the function (right after header).

A function was added to firmware, that runs right before main function (Appendix \ref{apx:gentable}). It starts walking package headers from the beginning of space allocated for such packages, jumping over function content based on length, and stops on first header with type nothing (\texttt{0xff}). Function pointers are added to function table, and global variables copied to their respective allocated memory areas.

\subsection{Function discovery and preparation}

Function preparation scripts were tested against simple test functions, as well as \gls{aocs} repositories. It was discovered, that simple source code parsing is not suitable for discovering all kinds of global variables, especially matrices and other complex types. Therefore approach was changed, \texttt{-fdata-sections} was taken into use and global variable names were discovered from symbol tables after compilation instead. After that change, most functions and all globals were successfully packaged.

Only problem that remained with this process, was that functions with variable number of arguments, were not possible to package using proposed solution. It remains unsolved, how to typedef a function pointer to function with variable number of arguments.\todo{look at it one more time}

\subsection{Running application functions}

\subsubsection{Fully self-contained function}

As first test, a fully self contained function was written, meaning that it did not depend on any external variables or functions, including that it did not call any standard library or operating system methods. This function blinked a \gls{led} by writing appropriate values directly to \gls{mcu} registers.

Running this function, even though compiled independently of the rest of the firmware, was tested without any issues. Minor inconvenience noted was that debug symbols for application function are not available, when debugger loads firmware elf.

\subsubsection{Calling firmware functions}

Next, a function was written that blinks \glspl{led} by calling respective \gls{hal} methods. Several issues arouse, all of which were possible to mitigate, so that this test was also mostly successfully concluded.

Firstly, author was unable to find any way to tell GNU linker \texttt{ld} to use symbol addresses from a map file generated by prior linking. Even though \textcite{Dunkels2006} claims to have used just the map file for pre-linking, even requests on internet forums (\url{https://stackoverflow.com/q/48028126/7088748}) resulted in no information about how to achieve that. This resulted in the need to link firmware once alone, and then again with each application function, hoping that firmware layout stays unchanged. Initially that was not the case, but after explicitly specifying section order in linkerscript, layout consistency was achieved.

Secondly, issues arouse with the way GNU C compiler handles local constants. \Gls{hal} functions for accessing \gls{gpio} take a struct of port and pin as an argument. Unfortunately, compiler placed the structs to \texttt{.rodata} section separately from function code, even though they were local. Even when placing function's \texttt{.text} and respective \texttt{.rodata} containing only function's local constants side by side with linker, compiler has already generated code that expects to use absolute memory addresses. More about that issue can be found from section \ref{rodata}. For the purpose of this test, the issue was mitigating by storing all pin-s and ports to single-byte local variables, that the compiler decided to store directly within the code section.

\subsection{Performance}

Performance overhead per function call was determined to be 3 instructions. Storage overhead per function was 12\glspl{b}. 

\TODO{Average size and time of functions.}

\subsection{Section .rodata}\label{rodata}

When compiler finds local constants in functions, that are longer than a byte, it separates them from the code, and creates \texttt{.rodata} section for them. The \texttt{.text}
section will contain relative reference (\texttt{//1}) to an absolute address (\texttt{//2}) inside the \texttt{.text}, which in turn points to the data (\texttt{//3}) inside \texttt{.rodata} (figure \ref{fig:rodata}). This structure remains even when linker is told to put \texttt{.text.function} and corresponding \texttt{.rodata} into single output section.

\begin{figure} [htb]
\begin{lstlisting}[language=C]
int function() { int a[] = {97, 98, 99, 100, 101, 103}; }
\end{lstlisting}
\begin{lstlisting}[style=asm]
// Undesirable:
0000 <.text.function>:
/---/
6:  4b07    ldr     r3, [pc, #28] ; (24 <function+0x24>) //1
/---/
24: 0000    .word   0x0000 //2 absolute address of .rodata, currently not linked
0000 <.rodata>: // absolute address will be replaced by linker
0:  0061    .word   0x0061 //3
4:  0062    .word   0x0062
8:  0063    .word   0x0063
c:  0064    .word   0x0064
10: 0065    .word   0x0065
14: 0067    .word   0x0067
\end{lstlisting}
\caption{Local constants after compilation with GNU C compiler}
\label{fig:rodata}
\end{figure}

Even when using \gls{pic}, code uses expressions relative to the \gls{pc} to access the \gls{got}, but \gls{got} still contains absolute memory addresses to \texttt{.rodata}. However, in all cases, absolute memory addresses to application function components, even when in the \gls{got}, are undesirable, because by requirements, code should not require on-board modifications and should be movable in memory space.

Help requests in online forums (\url{https://stackoverflow.com/q/45371949/7088748}) and compiler support mailing lists (\url{https://gcc.gnu.org/ml/gcc-help/2018-03/msg00015.html}) remained unanswered.

This is not a principle problem with proposed approach, since the compiler is already storing data (absolute memory addresses in this case) at the end of the \texttt{.text} section, and refering to it by \gls{pc}-relative expressions. Just as well could the local constants themselves be stored there. Instead, this 
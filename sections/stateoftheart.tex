\newpage
\section{State of the art}

This paper is by no means first time the problem of updating embedded systems has been tackled. However, all existing systems have their drawbacks. This section describes what has been done in this field previously.

\subsection{Full system image replacement}

For example, on ESTCube-1, one of the ways to update on-board code was to recompile the entire code-base, including any changes, upload it to the satellite, and after the next reboot of the \gls{mcu}, this new code would be active \cite{Suenter2016}. This method benefits from rather simple design: compilation of complete system image is typically the default way to produce executables with embedded operating systems from day zero of development \todo{citation?}. Additionally, by replacing the entire system image, any interoperability issues are eliminated and next to none on-board processing is required. ESTCube-1 also had the ability to keep several such system images stored at any time, allowing switching between them in case of any unexpected problems \cite{Tarbe2013}. 

However, this kind of simple design also poses significant drawbacks, most importantly it requires large amounts of uplink, even if the chance was minor. For example, on ESTCube-2, the size of a firmware image for the \gls{cdhs} was typically between \todo{ec1 fw size and citation}. Since upload speeds were \todo{ec1 upload speed and citation}, it took up to \todo{firmware upload time and citation}. \TODO{Since ESTCube-2 is a mostly experimental satellite, it is preferred to update it in small parts and often.}

\subsection{Virtual machines and script interpreters}

Another method that is commonly used when new code needs to be uploaded frequently and in small parts, is to virtualize it somehow on board. For example interpreted scripting language pawn script was used on ESTCube-1 \cite{Suenter2016} and will be used on TTÃœ100 satellite \cite{Aasavaeli2017}. With this approach, some parts of the code are written as scripts and each script is stored in a separate file. Since scripts only interact with rest of the system through well-defined API-s, they can be modified without influencing any other parts of the system. Thanks to the abstraction layer that the script interpreter provides, script files can be moved and rearranged without difficulty. \todo{cite pawn}

However, not all of the on-board software can be rewritten this way. Script execution is significantly slower than the execution of native code \todo{script vs native speed comparison}. Additionally, scripts have limited access to other system resources through predefined API-s. This limits the usefulness of such approach.

\TODO{About actual virtual machines}

\subsection{Binary differences}

\subsection{Dynamically loaded modules}




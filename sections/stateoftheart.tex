\newpage
\section{Related work}

The problem of software updates on embedded systems has seen many different solutions so far. A brief overview of existing methods is given in this section.

\subsection{Full system image replacement}

% generic overview of what the method is (+ estcube-1)
For example, on ESTCube-1, one of the ways to update on-board code was to recompile the entire code-base, including any changes, upload it to the satellite, and after the next reboot of the \gls{mcu}, this new code would be active \cite{Suenter2016}. This method benefits from a rather simple design: compilation of complete system image is typically the default way to produce executables with embedded operating systems from day zero of development \todo{citation?}. Additionally, by replacing the entire system image, any interoperability issues are eliminated and next to none on-board processing is required. Support for full image replacement is often implemented as fallback even on systems that support other more advanced update mechanisms as well \cite{Tarbe2013,Greco2005,Garrido1998}.

% dual images
Additionally, several missions have had the ability to keep several such system images stored at any time, allowing switching between them in case of any unexpected problems. In some cases, like MINISAT01, one of the images was read-only and only other one could be modified \cite{Garrido1998}. However, in some other cases, like  ESTCube-1 \cite{Tarbe2013} and The Mars Exploration Rovers \cite{Greco2005}, it has been possible to update both firmware images independently. The former poses significant drawbacks: in the case of MINISAT01, complete firmware update took 2 full days, and for that duration the original launch firmware version had to be used \cite{Garrido1998}. 

\TODO{Few words about bootloaders on ESTCube-1 and Mars Exploration Rovers.}

% drawbacks + estcube-1
However, this kind of simple design also poses significant drawbacks. Most importantly, it requires large amounts of uplink, even if the change was minor. For example, on ESTCube-1, taking into account the size of the firmware, uplink speed and orbital parameters, uninterrupted firmware update would take about 1.5 days to complete \cite{Suenter2014}. In case of the MINISAT01, full firmware update took 2 complete days, while partial update could be done in few hours \cite{Garrido1998}. In case of The Mars Exploration Rovers, replacement of entire firmware image required uplinking 8 Megabytes of data, while a patch update that they completed only required the uplinking of approximately 2 Megabytes \cite{Greco2005}.

\subsection{Virtual machines and script interpreters}

Another method that is commonly used when new code needs to be uploaded frequently and in small parts, is utilize visualization techniques on board. For example interpreted scripting language pawn script was used on ESTCube-1 \cite{Suenter2016} and will be used on TTÃœ100 satellite \cite{Aasavaeli2017}. With this approach some parts of the code are written in native code and some as scripts. Since scripts only interact with rest of the system through previously defined API-s, they can be modified without influencing any other parts of the system. Thanks to the abstraction layer that the script interpreter provides, script files can be moved and rearranged without difficulty \cite{Riemersm}.

However, not all of the on-board software can be rewritten this way. Script execution is significantly slower than the that of a native code \todo{script vs native speed comparison}. Additionally, scripts have limited access to other system resources through predefined API-s.

\TODO{About actual virtual machines}

\subsection{Binary differences}

In order to overcome the large uplink requirements of full image replacement while keeping the benefits of native code, some authors have experimented with calculating a delta between two system images and using it to recreate new image on-board.

One of the simplest binary difference based approaches for delta software updates was implemented on MINISAT01. Their entire firmware image consisted of 32 parts, and they could be updated separately. While updating the whole firmware took two full days, updating a single part could be done in just few hours. However, this approach had a serious limitation: old and updated codes had to be exactly binary compatible, no lengths could be changed. Therefore this kind of approach is only useful for updating values of constants, since code updates typically also change the length of compiled binary. \cite{Garrido1998}

To overcome this limitation, MINISAT01 also featured third method of updating on-board software. With this method, new or updated functions were located at the end of the firmware, while old versions were kept on their original locations. Then any calls to modified functions were changed in on-board software. This was possible, since modifying function call with new location does not change the length of the call, and MINISAT01 stored its firmware in \gls{eeprom}. \cite{Garrido1998} \todo{what is Global Description Table?}

A more complex approach to binary difference based software updates was taken on The Mars Exploration Rovers. They calculated differences between new and old firmware images that could start and end at arbitrary locations and change image size as well. However, to achieve this, they had to build the updated image in volatile memory and then store generated updated image in non-volatile memory. This meant that they had to reserve full day to assemble, validate and store the updated software. During that time no other activities could be carried out. They also acknowledge that "The single biggest improvement to the Mars Explorer Rovers' flight software modification process would be to reduce the amount of time necessary to stand down from nominal surface operations." \cite{Greco2005}

\subsection{Dynamically loaded modules}

Early solutions in desktop operating systems for loading new software programs without changing the entire system used hardware \gls{mmu} to provide virtual separate memory space for each component \todo{citation (PIC) required}. This way code could be statically linked without conflicts. Embedded systems that have an \gls{mmu}, have similarly used server-side pre-linking of software \cite{Shen2010}.

A very similar problem to that of embedded systems without an \gls{mmu} has been solved on desktop for shared libraries. While on embedded systems code modifications are undesirable due to limited computational power and the use of Flash memory, on desktop systems code modifications would force several versions of the same library to be kept in memory. Neither can be statically linked in order to avoid conflicts between different modules. The solution is to compile software in a position independent manner by introducing some sort of jump table for indirection \cite[Chapter~8]{Levine1999}. Hybrid solutions of pre-linking and pre-locating combined with dynamic re-location have also been explored \cite{Dong2009}. 

The jump table can be part of the operating system memory or part of each module. Example of the former can be found in the SOS operating system, where each module has to register functions into the jump table \cite{Han2005}. The latter approach has been implemented in, for example, Contiki OS, that makes use of modified \gls{elf} to hold code alongside its \gls{got} \cite{Dunkels2006}. Unfortunately, dynamic linking of \gls{elf} files is still not widely supported on embedded operating systems \cite{Xinyu2017}. Among others like it, FreeRTOS (the operating system used on ESTCube-2 \gls{obc}) does not support loading modules dynamically \cite{Barry2005}. \textcite{Xinyu2017} describes a method for including the code relocation functionality into the relocatable code itself as one possible solution.



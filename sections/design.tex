\newpage
\section{Design approach}

After use cases and existing solutions were analyzed, it was determined, that exists room for improvement. Requirements for a system that would be more suitable for ESTCube-2 than any existing alternatives, were defined. Possible design for meeting those requirements was proposed.

\subsection{Requirements}

Software updating system, that would be more suitable for ESTCube-2 than any existing alternatives, must:

\begin{itemize}
	\item allow addition of program code without the need to re-transmit significant portions of already existing code.
	\item allow changing a subset of existing code without the need to re-transmit significant portions of unchanged code.
	\item not require on-board modifications of uploaded code. This makes it possible to store code directly in internal Flash in case external memory modules are unavailable. 
	\item not depend on \gls{os} features unavailable in FreeRTOS.
	\item not significantly reduce code performance compared to system that uses full image replacement.
	\item support full inter-component communication. This enables any unforeseen updates as well, which a predefined \gls{api} could limit.
	\item \TODO{other requirements}
\end{itemize}

\subsection{Proposed solution}

% divided into firmware and functions
Proposed solution divides on-board software into two parts: firmware (startup script, \gls{hal}, \gls{os}, and critical device drivers) and application software (everything else) (figure \ref{fig:swOrg}). Firmware would be updateable by means of full image replacement, similar to how updates worked on ESTCube-1, including keeping two versions. This is proposed since firmware is expected to be updated rarely, if ever, and is too critical to apply experimental updating methods to it. 

% divided by function
Application software, on the other hand, would be divided into parts, so that each function would be separately. Each application function would be prepended with a short header (table \ref{tab:header}). Each function could then be independently updated, added or removed.

\begin{figure}[h]
	\centering
	\tiny
	\def\svgwidth{\columnwidth}
	\input{figures/On-board_software_organisation.pdf_tex}
	\caption{Proposed on-board software organization.}
	\label{fig:swOrg}
\end{figure}

\begin{table}[h]
	\centering
	\begin{threeparttable}
		\caption{Application functions header.}
		\begin{tabular}{r|l|l}
			\bf{Length} & \bf{Field} & \bf{Format} \\
			\hline
			4 \glspl{b} & \Gls{crc} & \\
			\hline
			1 \gls{b} & Type &
			\begin{tabular}{r|l}
				\texttt{0xff} & nothing \\
				\texttt{0xaa} & function \\
				\texttt{0x55} & global \\
				\texttt{0x00} & disabled \\	
			\end{tabular} \\
			\hline
			2 \glspl{b} & Function ID & uint16 \\
			\hline
			1 \gls{b} & Version nr & uint8 \\
			\hline
			2 \glspl{b} & Length of body & uint16 \\
			\hline
			2 \glspl{b} & \Gls{sram} offset (global variables only) & uint16 \\
		\end{tabular}
		\begin{tablenotes}
			\small
			\item Header will have \texttt{nop}-s appended to it to pad it to 12 \glspl{b} in length
		\end{tablenotes}
		\label{tab:header}
	\end{threeparttable}
\end{table}

% snapshots
On the ground during compilation correctness of function usage, function version dependencies etc should be checked. Dependencies would be managed by a system of snapshots similar to git: after new functionality has been developed and tested, current version of all functions is recorded, \gls{mcs} will then determine what functions differ when compared to satellites internal storage, and upload those.

\subsubsection{On-board storage of application software}

Main focus is on storing application functions in internal Flash. While Flash memory does not support deleting of changing any data other that deleting entire sector, it can be used as appendable storage. Functions would therefore be written to flash sequentially as they arrive. Additionally, Flash allows the addition of zeros into data. This allows marking functions as disabled, by replacing some pre-defined area of function header with zeros (type in table \ref{tab:header}). In order to change a function, a new version would simply be appended to the storage. If several versions of a function are found in memory, the last one would be considered correct.

\subsubsection{Linking}

Custom hybrid linking scheme would be applied. Firmware would be compiled and linked to a fixed memory address first. This way calls to all firmware functions from other firmware functions, as well as from any later added application function, can be simply linked on the ground.

Calling application functions is more tricky, as they can move around in memory. Additionally, firmware can't call functions, whose signatures are not known at the time of firmware compilation. For that reason, some functions are bundled with firmware (figure \ref{fig:swOrg}). They can be updated, but their signatures must remain unchanged.

Application functions can call each other by using a system-global offset table. This table contains the current memory address for each function. It is stored in volatile internal \gls{sram} and re-created every time the system boots (by walking over all stored functions and storing the address where each function appears last). It can be also changed during runtime, when new functions are added. Changing it on runtime when a function is changed, requires additional checks, to guarantee, that previous memory address does not remain in use (as some function pointer somewhere) and is therefore out of the scope of this work, but is potential future improvement.

Function table can not be implemented as branch table, as flash and ram are too far away in the memory. Function table would therefore contain function pointers, 4 bytes per function. Storing 3 bytes per function would require 2 instructions additional overhead per function call, so it was decided that 4 bytes per function will be stored (Appendix \ref{apx:calls}). Pointers will be pointing to the first instruction of the function (after header).

Function table should be periodically checked for errors. Function checksums should be checked during generation of the function table. During reboot flash memory can also be defragmented.

\subsubsection{Compiling application functions}

Compilers support function call indirection out of the box for \gls{pic} code, but since this proposal includes separating all functions, default tools fail to merge \glspl{got} properly. To avoid having to modify compiler itself, a way to rewrite all function calls using preprocessor was devised.

Compiler will have header available, that contains preprocessor function-like macros for each application function that have matching names with functions (figure \ref{fig:macro}). They will contain instructions to read function address from function table, cast it to the function type, cast all arguments to required types, and call the function.  The macro that corresponds to the function being compiled, will be removed using \texttt{\#undefine}. Such approach allows separation of functions be invisible to the developers.

\begin{figure} [htb]
\begin{lstlisting}[language=C]
typedef void (*stuffDoer_t)();
define stuffDoer() (*((stuffDoer_t)(*((uint32_t *) 0x20000000))))()
\end{lstlisting}
\caption{Example call interception macro for hypothetical function called \texttt{stuffDoer()}.}
\label{fig:macro}
\end{figure}

For calling important functions, the checksum of the function table can be checked immediately before jumping. Normally this is not done.

\subsubsection{Global variables}

Globals would be compiled into object files - compiler decides their length. Compilation should be  \texttt{-fdata-sections}, then linker can place them in memory independently. Functions would be linked with the globals available and later separated from binary using \texttt{objcopy}.

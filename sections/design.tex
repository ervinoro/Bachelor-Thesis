\newpage
\section{Design approach}

After use cases and existing solutions were analyzed, it was determined, that exists room for improvement. Requirements for a system that would be more suitable for ESTCube-2 than any existing alternatives, were defined. Possible design for meeting those requirements was proposed.

\subsection{Requirements}

Software updating system, that would be more suitable for ESTCube-2 than any existing alternatives, must:

\begin{itemize}
	\item allow addition of program code without the need to re-transmit significant portions of already existing code.
	\item allow changing a subset of existing code without the need to re-transmit significant portions of unchanged code.
	\item not require on-board modifications of uploaded code. This makes it possible to store code directly in internal Flash in case external memory modules are unavailable. 
	\item not depend on \gls{os} features unavailable in FreeRTOS.
	\item not significantly reduce code performance compared to system that uses full image replacement.
	\item support full inter-component communication. This enables any unforeseen updates as well, which a predefined \gls{api} could limit.
	\item \TODO{other requirements}
\end{itemize}

\subsection{Proposed solution}

% divided into firmware and functions
Proposed solution divides on-board software into two parts: firmware (startup script, \gls{hal}, \gls{os}, and critical device drivers) and application software (everything else) (figure \ref{fig:swOrg}). Firmware would be updatable by means of full image replacement, similar to how updates worked on ESTCube-1, including the use of multiple versions. This is proposed since firmware is expected to be updated rarely, if ever, and is too critical to use experimental updating methods with it. 

% divided by function
Application software, on the other hand, would be divided into parts, each containing single function. Each application function would be combined with a short header (table \ref{tab:header}) to a package. Each function could then be independently updated, added or removed.

\begin{figure}[h]
	\centering
	\tiny
	\def\svgwidth{\columnwidth}
	\input{figures/On-board_software_organisation.pdf_tex}
	\caption{Proposed on-board software organization.}
	\label{fig:swOrg}
\end{figure}

\begin{table}[h]
	\centering
	\begin{threeparttable}
		\caption{Application functions header.}
		\begin{tabular}{r|l|l}
			\bf{Length} & \bf{Field} & \bf{Format} \\
			\hline
			4 \glspl{b} & \Gls{crc} & \\
			\hline
			1 \gls{b} & Type &
			\begin{tabular}{r|l}
				\texttt{0xff} & nothing \\
				\texttt{0xaa} & function \\
				\texttt{0x55} & global \\
				\texttt{0x00} & disabled \\	
			\end{tabular} \\
			\hline
			2 \glspl{b} & Function ID & uint16 \\
			\hline
			1 \gls{b} & Version nr & uint8 \\
			\hline
			2 \glspl{b} & Length of body & uint16 \\
			\hline
			2 \glspl{b} & \Gls{sram} offset (global variables only) & uint16 \\
		\end{tabular}
		\begin{tablenotes}
			\small
			\item Header will have \texttt{nop}-s appended to it to pad it to 12 \glspl{b} in length
		\end{tablenotes}
		\label{tab:header}
	\end{threeparttable}
\end{table}

% snapshots
Function version dependencies would be managed by a system of snapshots similar to git: after new functionality has been developed and tested, current version of all functions is recorded, \gls{mcs} will then determine, which of them differ when compared to satellites internal storage, and upload those.

\subsubsection{On-board storage of application software}

Main focus is on storing application functions in internal Flash, since it is the most restrictive storage, and also in case of safe mode, this is the sole non-volatile storage available. Storage of some functions in other memories, as well as moving functions between different memories and addresses, would also be possible.

While Flash memory does not support deleting or changing any data short of the entire sector, it can be used as appendable storage. Functions would therefore be written to flash sequentially as they arrive. Additionally, Flash allows the addition of zeros into data. This way functions could be marked as disabled by replacing some predefined area of function header with zeros (type in table \ref{tab:header}), without the need to delete the sector. In order to change a function, a new version would simply be appended to the storage. If several versions of a function are found in memory, the last one will be considered correct.

\subsubsection{Linking}

Compiled code contains many symbol references: function calls, global variables, etc. For software to run, all of them must be replaced with absolute memory addresses. In order to satisfy all requirements (especially about no modifications to uploaded code), combination of static pre-linking and custom dynamic linker would be used.

Firmware would be compiled and linked to a fixed memory address first - meaning that absolute memory addresses of all functions and global variables in the firmware would be fixed. This way calls to all firmware functions from other firmware functions, as well as from any later added application function, can be simply linked on the ground.

Calling application functions is more tricky, as they can move around in memory. They would be callable by using a system-global offset table. This table would contain the current memory address for each function. It is stored in volatile internal \gls{sram} and re-created every time the system boots (by walking over all stored functions and storing the address where each function appears last). It can be also changed during runtime, when new functions are added. Changing it on runtime when a function is changed, requires additional checks, to guarantee, that previous memory address does not remain in use (as some function pointer somewhere) and is therefore out of the scope of this work, but is potential future improvement.

Additionally, firmware can't call functions, whose signatures are not known at the time of firmware compilation. For that reason, some functions are bundled with firmware (figure \ref{fig:swOrg}). They can be updated, but their signatures must remain unchanged.

Function table can not be implemented as branch table, as flash and ram are too far away in the memory. Function table would therefore contain function pointers, 4 bytes per function. Storing 3 bytes per function would require 2 instructions additional overhead per function call, so it was decided that 4 bytes per function will be stored (Appendix \ref{apx:calls}). Pointers will be pointing to the first instruction of the function (after header).

Function table should be periodically checked for errors. Function checksums should be checked during generation of the function table. During reboot flash memory can also be defragmented.

\subsubsection{Compiling application functions}

Compilers support function call indirection out of the box for \gls{pic} code, but since this proposal includes separating all functions, default tools fail to merge \glspl{got} properly. To avoid having to modify compiler itself, a way to rewrite all function calls using preprocessor was devised.

Compiler will have header available, that contains preprocessor function-like macros for each application function that have matching names with functions (figure \ref{fig:macro}). They will contain instructions to read function address from function table, cast it to the function type, cast all arguments to required types, and call the function. The macro that corresponds to the function being compiled, will be removed using \texttt{\#undefine}. Such approach allows separation of functions be invisible to the developers.

\begin{figure} [htb]
\begin{lstlisting}[language=C]
typedef void (*stuffDoer_t)();
#define stuffDoer() (*((stuffDoer_t)(*((uint32_t *) (FunctionTable + 0)))))()
\end{lstlisting}
\caption{Example call interception macro for hypothetical function called \texttt{stuffDoer()}, id 0.}
\label{fig:macro}
\end{figure}

For calling important functions, the checksum of the function table can be checked immediately before jumping. Normally this is not done.

\subsubsection{Global variables}

In order to simplify the design, globals would be treated very similarly to functions. First, they would be compiled so that compiler would calculate length. Compilation should be \texttt{-fdata-sections}, then they can be extracted to separate packages, prepended with headers, and uploaded to the satellite.

Memory space after .data and before heap would be reserved for updatable globals. Linker would decide position for each variable in that area, and then all functions using the variable could be statically pre-linked on ground. Headers for globals would contain appropriate type, and additionally the memory address allocated for this variable. During boot, when function addresses are being added to offset table, global variables would be copied to respective addresses. As with function, latest occurrence overrides any previous ones.

\subsubsection{Implementation details}

Set of python scripts was developed to aid with function compilation and packaging. Functions were discovered and allocated by searching function definitions from all source files. Global variables were extracted from symbol tables after all object files were compiled. Reason for this difference is that argument types must also be know about functions. Data about functions and globals, along with respective object codes, was stored in a SQLite3 database. Scripts were also created for generating interception header, linkerscript, and packages with headers.
